\section{Related Work} \label{sec:related_work}

There are four research areas relevant to this work, namely reengineering of systems into SPL, clone-and-own, search-based software engineering, and software transplantation.

%\subsection{Reengineering for \ac{SPL}}
\textbf{Reengineering of Systems into SPL}. Diverse academic proposals and industrial experience reports addressing reengineering for extractive SPL are present in the literature, as shown in Assuncao et al.â€™s mapping study~\cite{Assuncao2017}. However, this number decreases considerably when we are interested in proposals that automate the lifecycle of the reengineering process~\cite{Kruger2020}. In many papers, the authors expose only an intention to provide a tool support for their approaches. Some initiatives have been providing solutions for reengineering product family into a configurable product line~\cite{Faust2003, Mende2008, Koschke2007}. Others provide support for specific tasks~\cite{Martinez2015, Alves2007, Nunes2012, Klatt2014, Tang2015}. These studies can provide interesting solutions to reengineering practices. Nevertheless, unlike FOUNDRY, such approaches do not adapt target features automatically. Moreover, the feature integration in an SPL is semi-automatic, while FOUNDRY requires no effort from the developers for this process.

Ziadi et al.~\cite{Ziadi2014} introduces \emph{But4Reuse}, an extraction-based technique for product-line migration, including support for feature-model synthesis. But4Reuse has the advantage of working on various cases (different programming languages and artifacts) thanks to its adapters system. However,  variability within the body of methods or functions (i.e. the statement level), which causes significant duplicates in the different features of their SPL representation. Finally, the maintenance and evolution can only be done by re-extracting the entire product line after modifying the products. With \autoscalpel, we allow developers to directly manipulate an SPL implementation through their over-organs, which are accessible for them possible to be individually maintained and tested, for example, using unit testing approaches with the original feature playing the role of oracle.

\emph{IsiSPL}~\cite{hlad2021} is a reactive approach to SPL adoption in the software industry. IsiSPL automates the integration and generation phases in a non-invasive development cycle. However, it proposes a representation of an SPL implementation in the form of an annotated code, what have impact on the code comprehension, even performing a simplification that removes redundant annotations.

%\subsection{Clone-and-own}
\textbf{Clone-and-own}. Clone-and-own was proposed as a simple alternative to SPL~\cite{Dubinsky2013, Fischer2015, Krinke2010, Ray2012, Martinez2015, Stanciulescu2015}. 
It is an ad hoc reuse practice that creates new products in a software family by copying and adapting an existing product~\cite{Dubinsky2013, Fischer2015}. \FOUNDRY also can be exploited as an automated alternative to clone-and-own approach to the optimization of the product development process, where it is used as a one-off to create a new product. Although there are tools for feature location from code-and-clone detection techniques, the adaptation of feature to reuse still requires manual work~\cite{Yoshimura2006, Kastner2014}. 

Fischer et al.~\cite{Fischer2015}, for instance, present \emph{ECCO} to enhance clone-and-own. The tool finds the proper software artifacts to reuse and then provides guidance during the manual completion by hinting at which software artifacts may need adaptation. Like \autoscalpel, ECCO also produces a black-box representation of a product line implementation, with no annotated code, which easily the maintenance process of its product line. However, ECCO requires that its features source must be based on the same family of products which limits the capacity of reusing assets. Furthermore, ECCO considers the code in the body of methods as raw lines, each line of code being a new artefact, which complicates the evolution process of an SPL. Whereas in FOUNDRY, the product line representation stores an over-organ that can be automatically "pruned" to be adapted to different products variation. Additionally, \autoscalpel relies on a clone detector to deal with the variability relationship, namely the implication, the mutual exclusion, the co-occurrence, and the common and optional feature. This means that \autoscalpel recognize these relationships independently of the human intervention or by requiring any other artefact besides the source code.

\textbf{Search-based Software Engineering}. In their keynote paper, Harman and colleagues advocate the potential the application of search-based algorithms, as genetic improvement~\cite{Petke18:genetic}, for SPL development~\cite{Harman2014a}, for instance, in migrating products into an SPL~\cite{Rubin2013b, Fischer2014}. Harman et al. present a survey with directions for future work on SBSE with applications in SPL~\cite{Harman2014a}. Regarding the re-engineering process, the authors present some research on reverse engineering of feature models, applying search-based techniques. Since then, new studies~\cite{Segura2013,  Linsbauer2014, Lopez2015}  applying search-based algorithms for feature model generation appeared. We are the first to propose an approach and evaluate a tool for SPL migration using SBSE.

\textbf{Software Transplantation}. As far as the literature on automated software transplantation is concerned, Petke et al.~\cite{Petke2014,Petke2018} were the first to transplant snipets of code from various versions of the same system to improve its performance, using genetic improvement~\cite{Petke18:genetic}. One year later, Barr et al. successfully transplanted a feature from one program into another~\cite{Barr2015}. 
More recently, Petke et al.~\cite{Petke2018} used transplantation for genetic improvement-based specialisation. In contrast, we explore multi-organ ST for SPL generation. We focus on how transplantation can be used for extracting the intended code from different donors, inserting a variability mechanism and deploying it in a prepared product base in order to build product lines or new products.


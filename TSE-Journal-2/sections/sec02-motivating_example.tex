\section{Motivating Example} \label{sec:motivating_example}


We chose the open-source GNOME project\footnote{https://wiki.gnome.org/Projects} as our motivating example. GNOME  project encompasses a large portfolio of individual programs, separately maintained. These programs share features, but GNOME cannot easily reuse features across its portfolio. It is a natural candidate for SPL, but has not adopted it, because of the prohibitive cost of this task.  \FOUNDRY is transformative because it can be used to reduce the cost of adopting SPL.

We now show how to GNOME team can apply \FOUNDRY to quickly generate one or more product lines, using \autoscalpel. Suppose project collaborators want to build a product line in the domain of text editors using \FOUNDRY to reuse features from existing systems. This product line would make GNOME project able to produce customized text editors with features that its current text editor, \emph{GEdit}\footnote{https://wiki.gnome.org/Apps/Gedit}, lacks. We assume that the GNOME team has determined that there is a market/demand for such a product and targets the following three features (1) $\texttt{side-panel}$, (2) $\texttt{split pane}$, and (3) $\texttt{presentation}$. They then identify two donors from which to transplant these features:  \emph{NEdit}\footnote{https://sourceforge.net/projects/nedit/}, a multi-purpose text editor, and \emph{Evince}\footnote{https://wiki.gnome.org/Apps/Evince}, a document viewer for multiple document formats. 
 
The process is executed in an iterative and incremental fashion by using \autoscalpel. In the first step (in a preoperative stage) the donors and the host are prepared for the transplantation process. For the donor's preparation, \autoscalpel is used by GNOME engineers to remove all portions of code surrounded by preprocessor directives. Although useful for donor programs, some conditional directives, if transplanted, will generate dead code — unnecessary code fragments~\cite{Tartler2011} that will never be included in any valid feature selection. For the host preparation, a \emph{product base} needs to be selected from existing systems. A  product base is used as a core of the product line, serving as a host for features to be transplanted. 

The GNOME development team then selects GEdit as a product base for the target product line. It is chosen for already had some commonalities (i.e. common features) among the products to be derived from the GNOME product line. However, GEdit has unwanted features for the product line portfolio that need to be removed. This task is usually costly, tedious and error-prone, if done manually. \autoscalpel provides an automated way for removing optional features from a product base when it is implemented with preprocessor statements like \#IFDEFS in C and C++. 

Once they have the product base from GEdit, the developers must then augment it with annotations to demarcate implantation points for each target feature, or “organ” using transplantation nomenclature. They also need to demarcate organ entry points for each one to be transplanted. Note that the features do not need to be explicitly defined, using preprocessor directives or any other mechanism. \autoscalpel only requires annotation of the entry point of the method implementing the desired feature. 

The pre-operative process produces a product base, adapted to receive all variant features transplanted from the donor programs. Then, the engineers can run \autoscalpel to transplant the three features targeted above. For each feature, \autoscalpel automatically extracts all of that feature's source code and its dependencies, or “over-organ” using transplantation nomenclature, using \emph{program slicing}~\cite{Binkley:2014:OLP:2635868.2635893} technique. The extracted over-organ is added to an \emph{Icebox} repository, a repository from which over-organs are kept to be reused by using the transplantation process.

For producing new product variants, \autoscalpel implements an observational slicing in Genetic Programming (GP)~\cite{Harman2009} that reduces the organ and adapt it to execute in the product base. \autoscalpel first transplants the \emph{side-panel} feature, extracted from GEdit itself. This transplantation demonstrates that \autoscalpel can transplant features into a product base that comes from the same codebase. It shows how developers can use \autoscalpel to produce a customized product from a single product base. Next, \autoscalpel transplants the \emph{split\_pane} feature from NEdit, which is an editor like GEdit, but not part of the GNOME portfolio. It shows how \autoscalpel manage to transplant features from distinct codebases, which is not possible without manual effort using the current state-of-art to SPL re-engineering. Finally, \autoscalpel transplants the \emph{presentation} feature from the Evince program, which is a GNOME project, but not a text editor. %Figure~\ref{fig:incremental_pd} illustrates this process. 

Using \FOUNDRY different products variants may be derived from a thus created product line upon request by using software transplantation. The transplantation technique applied by \FOUNDRY generates a representation of an SPL implementation without any annotated code. The annotation-based representation suffers from its negative effect on code understanding, maintainability and error proneness when many annotations appear in the code. Annotated code can become unreadable and hard to be maintained~\cite{Nicolas2021}. This is often referred to as the \emph{if/else hell} problem~\cite{Tartler2011, Aleixo2012, Medeiros2015}. %~\cite{Tartler2011}. 

We envision two ways of maintaining such created product line. 
Firstly, one can re-transplant the features if the original source codebase changes. This is thus already supported by \autoscalpel.
Secondly, one can maintain the extracted over-organs, and re-run the adaptation and implantation stages, as need be. \pl{tu acha q vale a pena colocar a palavra maintaining em negrito para destacar mais? como o texto ta grande e denso eu acho que vale a pena destacar de alguma forma. Italico}

\FOUNDRY can also be exploited as an alternative to directly generating variants of GEdit. For this, \autoscalpel can be used to create a single product by transplanting these target features in the original version of GEdit, without any variability mechanism.

\FOUNDRY can open the door to transplanting features from any program  into a product line, scaling up feature reuse. 
% throughout the  product portfolio. 
Open-source projects, like GNOME, are a promising source of code for the concept of software transplantation for SPL reengineering. Open-source code enables every developer the opportunity to share code, allowing them to migrate an already existing code from a pre-existing source into their own SPL project.

